'use strict';

const dgram = require('dgram');
const { Duplex } = require('readable-stream');
const debug = require('utils/debug')('dtls:server');
const CookieManager = require('lib/cookie-manager');
const { decode, encode } = require('binary-data');
const {
  contentType,
  handshakeType,
  protocolVersion,
} = require('lib/constants');
const {
  DTLSPlaintext,
  Handshake,
  ClientHello,
  HelloVerifyRequest,
} = require('lib/protocol');

const _session = Symbol('_session');
const _socket = Symbol('_socket');

/**
 * @typedef {Object} DTLSServerOptions
 * @property {dgram.Socket} [socket] dgram socket
 * @property {string} [type] dgram type socket
 * @property {CookieManager} [cookie] shared cookie
 * @property {Buffer} [options.certificate] Server certificate
 * @property {Buffer} [options.certificatePrivateKey] Private key of the server certificate
 * @property {number[]} [options.cipherSuites] List of supported cipher suites
 */

/**
 * DTLS server.
 */
class Server extends Duplex {
  /**
   * @class Server
   * @param {DTLSServerOptions} options
   */
  constructor(options = {}) {
    super({ objectMode: false, decodeStrings: false });

    const { socket, cookie } = options;

    this[_session] = null;
    this[_socket] = socket;

    socket.on('message', (message, rinfo) => {
      debug('got a new chunk');

      // Session is not started.
      if (this[_session] === null) {
        const status = isCookieValid(cookie, message);

        if (status === 0) {
          const response = createHelloVerifyRequest(cookie);
          socket.send(response, rinfo.port, rinfo.address);
        }

        if (status === 1) {
          debug('start session');
        }
      }
    });
  }
}

/**
 * Handle client's ClientHello message by checking cookie.
 * @param {CookieManager} cookie
 * @param {Buffer} message
 * @returns {number}
 */
function isCookieValid(cookie, message) {
  debug('process ClientHello');
  const record = decode(message, DTLSPlaintext);

  if (record.type !== contentType.HANDSHAKE) {
    debug('not a handshake - %s, ignore', record.type);
    return -1;
  }

  const handshake = decode(record.fragment, Handshake);

  if (handshake.type !== handshakeType.CLIENT_HELLO) {
    debug('not a ClientHello - %s, ignore', handshake.type);
    return -1;
  }

  // Ignore fragmented (first) ClientHello due to potencial DoS.
  if (handshake.length !== handshake.fragment.length) {
    debug('got fragmented ClientHello, ignore');
    return -1;
  }

  const clientHello = decode(handshake.body, ClientHello);

  // Send HelloVerifyRequest
  if (clientHello.cookie.length === 0) {
    return 0;
  }

  if (cookie.validate(clientHello.cookie)) {
    debug('cookie is valid');
    return 1;
  }

  debug('invalid cookie, ignore');
  return -1;
}

/**
 * Send HelloVerifyRequest message.
 * @param {CookieManager} cookie
 * @returns {Buffer}
 */
function createHelloVerifyRequest(cookie) {
  const helloVerifyRequest = {
    serverVersion: protocolVersion.DTLS_1_2,
    cookie: cookie.current,
  };

  const handshakePayload = encode(
    helloVerifyRequest,
    HelloVerifyRequest
  ).slice();

  const handshake = {
    type: handshakeType.HELLO_VERIFY_REQUEST,
    length: handshakePayload.length,
    sequence: 0,
    fragment: {
      offset: 0,
      length: handshakePayload.length,
    },
    body: handshakePayload,
  };

  const headerPayload = encode(handshake, Handshake).slice();

  const record = {
    type: contentType.HANDSHAKE,
    version: protocolVersion.DTLS_1_2,
    epoch: 0,
    sequenceNumber: 0,
    length: headerPayload.length,
    fragment: headerPayload,
  };

  return encode(record, DTLSPlaintext).slice();
}

/**
 * Create DTLS server.
 * @param {DTLSServerOptions} options
 * @param {Function} callback
 * @returns {Server}
 */
function createServer(options, callback) {
  if (!options.socket) {
    options.socket = dgram.createSocket(options);
  }

  if (!options.cookie) {
    options.cookie = new CookieManager();
  }

  const server = new Server(options);

  if (typeof callback === 'function') {
    server.once('connect', callback);
  }

  return server;
}

module.exports = {
  createServer,
  Server,
};
