'use strict';

const { Readable } = require('readable-stream');
const debug = require('utils/debug')('dtls:sender');
const { createEncodeStream, encode } = require('binary-data');
const {
  contentType,
  handshakeType,
  compressionMethod,
  cipherSuites,
} = require('lib/constants');
const {
  Alert,
  Certificate,
  DTLSPlaintext,
  Handshake,
  ClientHello,
  EncryptedPreMasterSecret,
} = require('lib/protocol');
const { encryptPreMasterSecret } = require('session/utils');
const { constants: states, getProtocol } = require('fsm/states');
const {
  states: { SENDING },
} = require('fsm/retransmitter');

const changeCipherSpecMessage = Buffer.alloc(1, 1);
const defaultCompressionMethods = [compressionMethod.NULL];

const defaultCipherSuites = [
  cipherSuites.TLS_RSA_WITH_AES_128_GCM_SHA256,
  cipherSuites.TLS_RSA_WITH_AES_256_GCM_SHA384,
];

const {
  CLIENT_HELLO,
  FINISHED,
  CERTIFICATE,
  CHANGE_CIPHER_SPEC,
  CLIENT_KEY_EXCHANGE,
  HANDSHAKE,
} = states;

const EMPTY_BUFFER = Buffer.alloc(0);

const _output = Symbol('_output');
const _session = Symbol('_session');
const _drain = Symbol('_drain');
const _queue = Symbol('_queue');
const _clientHello = Symbol('_client_hello');
const _finished = Symbol('_finished');
const _certificate = Symbol('_certificate');
const _changeCipherSpec = Symbol('_change_cipher_spec');
const _clientKeyExchange = Symbol('_client_key_exchange');
const _alert = Symbol('_alert');
const _applicationData = Symbol('_application_data');

const senders = {
  [CLIENT_HELLO]: _clientHello,
  [FINISHED]: _finished,
  [CERTIFICATE]: _certificate,
  [CHANGE_CIPHER_SPEC]: _changeCipherSpec,
  [CLIENT_KEY_EXCHANGE]: _clientKeyExchange,
};

module.exports = class Sender extends Readable {
  /**
   * @param {AbstractSession} session
   */
  constructor(session) {
    super();

    const queue = [];
    const output = {
      alert: createEncodeStream(Alert),
      record: createEncodeStream(DTLSPlaintext),
      handshake: createEncodeStream(Handshake),
    };

    output.alert.on('data', packet => {
      this.sendRecord(packet, contentType.ALERT);
    });

    output.handshake.on('data', packet => {
      session.appendHandshake(packet);
      session.retransmitter.append(HANDSHAKE, packet);
      this.sendRecord(packet, contentType.HANDSHAKE);
    });

    output.record.on('data', packet => {
      if (session.isHandshakeInProcess) {
        debug('buffer packet');
        queue.push(packet);
      } else {
        this.push(packet);
      }
    });

    this[_output] = output;
    this[_session] = session;
    this[_queue] = queue;

    session.on('send', state => this[senders[state]]());

    session.on('send:appdata', payload => this[_applicationData](payload));
    session.on('send:alert', (description, level) =>
      this[_alert](level, description)
    );

    // Merge outgoing handshake packets before send.
    session.retransmitter.on(SENDING, () => this[_drain]());

    // Send stored handshake message again.
    session.retransmitter.on('data', (state, packet) =>
      this.sendRecord(packet, getProtocol(state))
    );
  }

  /**
   * @returns {{alert, record, handshake}}
   */
  get output() {
    return this[_output];
  }

  /**
   * @returns {AbstractSession}
   */
  get session() {
    return this[_session];
  }

  /**
   * @private
   */
  _read() {} // eslint-disable-line class-methods-use-this

  /**
   * @param {Buffer} message
   * @param {contentType} type
   */
  sendRecord(message, type) {
    const record = {
      type,
      version: this.session.version,
      epoch: this.session.clientEpoch,
      sequenceNumber: this.session.nextRecordNumber(),
      length: message.length,
      fragment: message,
    };

    if (type !== contentType.ALERT && type !== contentType.CHANGE_CIPHER_SPEC) {
      debug('encrypt, cipher = %s', this.session.cipher.blockAlgorithm);
      this.session.encrypt(record);
      debug('success');
    }

    this.output.record.write(record);
  }

  /**
   * @param {Buffer} message
   * @param {handshakeType} type
   */
  sendHandshake(message, type) {
    const { length } = message;

    const handshake = {
      type,
      length,
      sequence: this.session.nextHandshakeNumber(),
      fragment: {
        offset: 0,
        length,
      },
      body: message,
    };

    this.output.handshake.write(handshake);
  }

  /**
   * Send `Alert` message
   * @param {number} level
   * @param {number} code
   */
  sendAlert(level, code) {
    debug('send Alert');

    const message = {
      level,
      description: code,
    };

    this.output.alert.write(message);
  }

  /**
   * Send `Client Hello` message
   */
  [_clientHello]() {
    debug('send Client Hello');

    const clientHello = {
      clientVersion: this.session.version,
      random: this.session.clientRandom,
      sessionId: EMPTY_BUFFER, // We do not support resuming session. So, send empty id.
      cookie: this.session.cookie || EMPTY_BUFFER,
      cipherSuites: defaultCipherSuites,
      compressionMethods: defaultCompressionMethods,
    };

    const output = createEncodeStream();
    encode(clientHello, output, ClientHello);

    this.sendHandshake(output.slice(), handshakeType.CLIENT_HELLO);
  }

  /**
   * Send `Client Key Exchange` message
   */
  [_clientKeyExchange]() {
    debug('send Client Key Exchange');

    const pubkey = this.session.serverPublicKey;
    const premaster = this.session.clientPremaster;
    const encryptedPremaster = encryptPreMasterSecret(pubkey, premaster);

    const output = createEncodeStream();
    encode(encryptedPremaster, output, EncryptedPreMasterSecret);

    this.sendHandshake(output.slice(), handshakeType.CLIENT_KEY_EXCHANGE);
  }

  /**
   * Send `Change Cipher Spec` message
   */
  [_changeCipherSpec]() {
    debug('send Change Cipher Spec');

    this.session.retransmitter.append(
      CHANGE_CIPHER_SPEC,
      changeCipherSpecMessage
    );
    this.sendRecord(changeCipherSpecMessage, contentType.CHANGE_CIPHER_SPEC);
  }

  /**
   * Send `Certificate` message.
   * @param {Buffer} certificate
   */
  [_certificate](certificate) {
    debug('send Certificate');

    const packet = {
      certificateList: [],
    };

    if (Buffer.isBuffer(certificate)) {
      packet.certificateList.push(certificate);
    }

    const output = createEncodeStream();

    encode(packet, output, Certificate);

    this.sendHandshake(output.slice(), handshakeType.CERTIFICATE);
  }

  /**
   * Send `Finished` message.
   */
  [_finished]() {
    debug('send Finished');

    this.sendHandshake(this.session.clientFinished, handshakeType.FINISHED);
  }

  /**
   * Send `application data` message
   * @param {Buffer} payload
   * @private
   */
  [_applicationData](payload) {
    this.sendRecord(payload, contentType.APPLICATION_DATA);
  }

  /**
   * Send `alert` message
   * @private
   * @param {number} level
   * @param {number} description
   */
  [_alert](level, description) {
    this.output.alert.write({
      level,
      description,
    });
  }

  /**
   * Clears internal message buffer and sends packets.
   * @private
   */
  [_drain]() {
    if (this[_queue].length === 0) {
      debug('empty out queue');
      return;
    }

    const packets = Buffer.concat(this[_queue]);
    debug('drain queue, %s bytes', packets.length);

    this[_queue].length = 0;
    this.push(packets);

    this.session.retransmitter.wait();
  }
};
