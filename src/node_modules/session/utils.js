'use strict';

const assert = require('assert');
const crypto = require('crypto');
const { sessionType } = require('lib/constants');

const { RSA_PKCS1_PADDING } = crypto.constants;

/**
 * Check if argument is client type session.
 * @param {AbstractSession} session
 */
function assertClient(session) {
  assert((session.sessionType = sessionType.CLIENT));
}

/**
 * Check if argument is server type session.
 * @param {AbstractSession} session
 */
function assertServer(session) {
  assert((session.sessionType = sessionType.SERVER));
}

/**
 * Create unix time from now.
 * @returns {number}
 */
function unixtime() {
  return parseInt(Date.now() / 1e3, 10);
}

/**
 * @param {Buffer} random
 * @param {function} [done]
 */
function createRandom(random, done) {
  random.writeUInt32BE(unixtime(), 0);
  crypto.randomFill(random, 4, done);
}

/**
 * @param {number} version
 * @param {function} [done]
 */
function createPreMasterSecret(version, done) {
  const premaster = Buffer.allocUnsafe(48);

  premaster.writeUInt16BE(version, 0);
  crypto.randomFill(premaster, 2, done);
}

/**
 * @param {Buffer} clientRandom
 * @param {Buffer} serverRandom
 * @param {Buffer} premaster
 * @param {object} cipher
 * @returns {Buffer}
 */
function createMasterSecret(clientRandom, serverRandom, premaster, cipher) {
  const seed = Buffer.concat([clientRandom, serverRandom]);

  const label = 'master secret';
  const masterSecret = cipher.prf(48, premaster, label, seed);

  return masterSecret;
}

/**
 * @param {Buffer} publicKey
 * @param {Buffer} premaster
 * @returns {Buffer}
 */
function encryptPreMasterSecret(publicKey, premaster) {
  const encrypted = crypto.publicEncrypt(
    { key: publicKey, padding: RSA_PKCS1_PADDING },
    premaster
  );

  return encrypted;
}

/**
 * Create `Finished` message
 * @param {cipher} cipher
 * @param {Buffer} master master secret
 * @param {Buffer} handshakes list of all handshake messages
 * @param {string} label
 * @returns {Buffer}
 */
function createFinished(cipher, master, handshakes, label) {
  const bytes = hash(cipher.hash, handshakes);
  const final = cipher.prf(cipher.verifyDataLength, master, label, bytes);

  return final;
}

/**
 * @private
 * @param {string} algorithm hash algo
 * @param {Buffer} data data to encrypt
 * @returns {Buffer}
 */
function hash(algorithm, data) {
  return crypto
    .createHash(algorithm)
    .update(data)
    .digest();
}

module.exports = {
  createRandom,
  unixtime,
  assertClient,
  assertServer,
  createPreMasterSecret,
  createMasterSecret,
  encryptPreMasterSecret,
  createFinished,
};
