'use strict';

/* eslint class-methods-use-this: ["error", { "exceptMethods": ["type"] }] */
/* eslint-disable getter-return */

const assert = require('assert');
const Emitter = require('events');
const bl = require('bl');
const { createEncodeStream, encode } = require('binary-data');
const { protocolVersion } = require('lib/constants');
const { createMasterSecret, createPreMasterSecret } = require('session/utils');
const NullCipher = require('cipher/null');
const debug = require('utils/debug')('dtls:session');
const { Handshake } = require('lib/protocol');

module.exports = class AbstractSession extends Emitter {
  /**
   * @constructor
   */
  constructor() {
    super();

    this.version = protocolVersion.DTLS_1_2;
    this.clientRandom = null;
    this.serverRandom = null;
    this.clientEpoch = 0;
    this.serverEpoch = 0;
    this.recordSequenceNumber = 0;
    this.handshakeSequenceNumber = 0;
    this.clientFinished = null;
    this.serverFinished = null;
    this.id = null;
    this.mtu = 1200; // default value for Google Chrome

    this.isHandshakeInProcess = false; // getter from FSM?
    this.lastRvHandshake = -1; // for reordering

    this.cipher = new NullCipher();
    this.nextCipher = null;

    this.serverPublicKey = null;
    this.masterSecret = null;
    this.clientPremaster = null;

    this.handshakeProtocolReaderState = null;
    this.handshakeQueue = bl();

    this.retransmitter = null;
  }

  /**
   * Abstract method to get session type.
   */
  get type() {
    notImplemented();
  }

  /**
   * Emit event to send message.
   * @param {number} type message type to send
   */
  send(type) {
    this.emit('send', type);
  }

  /**
   * Send `application data` message
   * @param {Buffer} data
   */
  sendMessage(data) {
    this.emit('send:appdata', data);
  }

  /**
   * Send `alert` message
   * @param {number} description
   * @param {number} level
   */
  sendAlert(description, level) {
    this.emit('send:alert', description, level);
  }

  /**
   * Handles starts handshake.
   */
  startHandshake() {
    debug('start handshake');
    this.emit('handshake:start');

    this.isHandshakeInProcess = true;
    this.lastRvHandshake = -1;
    this.handshakeSequenceNumber = -1;
  }

  /**
   * Handshake successfully ends.
   */
  finishHandshake() {
    debug('stop handshake');
    this.isHandshakeInProcess = false;
    this.handshakeProtocolReaderState = null;
    this.resetHandshakeQueue();

    this.emit('handshake:finish');
  }

  /**
   * Emit event to notify an error.
   * @param {number} type alert description type
   */
  error(type) {
    this.emit('error', type);
  }

  /**
   * Notify application about server certificate.
   * @param {object} cert x509 server certificate
   */
  certificate(cert) {
    this.emit('certificate', cert);
  }

  /**
   * @protected
   * @param {function} done
   */
  createPreMasterSecret(done) {
    createPreMasterSecret(this.version, (err, premaster) => {
      if (err) {
        throw err;
      }

      this.clientPremaster = premaster;
      done();
    });
  }

  /**
   * @protected
   */
  createMasterSecret() {
    this.masterSecret = createMasterSecret(
      this.clientRandom,
      this.serverRandom,
      this.clientPremaster,
      this.nextCipher
    );
    this.clientPremaster = null;
  }

  /**
   * Starts next epoch for clients.
   */
  nextEpochClient() {
    this.clientEpoch += 1;

    this.cipher = this.nextCipher;
    this.nextCipher = null;

    this.cipher.init(this);
  }

  /**
   * Starts next epoch for server.
   */
  nextEpochServer() {
    this.serverEpoch += 1;
    assert(this.clientEpoch === this.serverEpoch, 'mismatch epoches');
  }

  /**
   * Increment outgoing sequence number of record layer
   * and return this one.
   * @returns {number}
   */
  nextRecordNumber() {
    this.recordSequenceNumber += 1;
    return this.recordSequenceNumber;
  }

  /**
   * Increment outgoing sequence number of handshake layer
   * and return this one.
   * @returns {number}
   */
  nextHandshakeNumber() {
    this.handshakeSequenceNumber += 1;
    return this.handshakeSequenceNumber;
  }

  /**
   * Store handshake message for finished checksum.
   * @param {Buffer} packet encoded handshake message
   */
  appendHandshake(packet) {
    assert(this.isHandshakeInProcess);

    if (!Buffer.isBuffer(packet)) {
      const output = createEncodeStream();
      encode(packet, output, Handshake);

      packet = output.slice(); // eslint-disable-line no-param-reassign
    }

    debug('packet added to handshake queue, type = %s', packet.readUInt8(0));
    this.handshakeQueue.append(packet);
  }

  /**
   * Sometimes we need to clear queue. Just re-create queue for this.
   */
  resetHandshakeQueue() {
    debug('reset handshake queue');
    this.handshakeQueue = bl();
  }

  /**
   * Encrypt outgoing record message.
   * @param {object} record record layer message
   */
  encrypt(record) {
    const data = record.fragment;

    const encrypted = this.cipher.encrypt(this, data, record);
    record.fragment = encrypted;
    record.length = encrypted.length;
  }

  /**
   * Decrypt incoming record message.
   * @param {object} record record layer message
   */
  decrypt(record) {
    const encrypted = record.fragment;
    const data = this.cipher.decrypt(this, encrypted, record);

    record.fragment = data;
  }

  /**
   * Notify about `application data` message.
   * @param {Buffer} data
   */
  packet(data) {
    this.emit('data', data);
  }
};

/**
 * Fallback for abstract methods.
 */
function notImplemented() {
  throw new Error('not implemented');
}
