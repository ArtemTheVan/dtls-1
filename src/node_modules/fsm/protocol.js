'use strict';

// Handshake protocol State Machine (DTLS 1.2)

const assert = require('assert');
const { Writable } = require('readable-stream');
const { constants: states, createState } = require('fsm/states');
const {
  contentType,
  alertDescription,
  maxSessionIdSize,
} = require('lib/constants');
const { decode } = require('binary-data');
const {
  HelloVerifyRequest,
  ServerHello,
  Certificate,
  Alert,
} = require('lib/protocol');
const debug = require('utils/debug')('dtls:protocol-reader');
const defaultCiphers = require('cipher/defaults');
const x509 = require('lib/x509');

const {
  CLIENT_HELLO,
  SERVER_HELLO,
  HELLO_VERIFY_REQUEST,
  CERTIFICATE,
  SERVER_KEY_EXCHANGE,
  CERTIFICATE_REQUEST,
  SERVER_HELLO_DONE,
  CERTIFICATE_VERIFY,
  CLIENT_KEY_EXCHANGE,
  FINISHED,
  CHANGE_CIPHER_SPEC,
} = states;

const FLAG_CLIENT = 2 ** 16 + 1;

const CLIENT_CERTIFICATE = CERTIFICATE | FLAG_CLIENT; // eslint-disable-line no-bitwise
const CLIENT_FINISHED = FINISHED | FLAG_CLIENT; // eslint-disable-line no-bitwise
const CLIENT_CHANGE_CIPHER_SPEC = CHANGE_CIPHER_SPEC | FLAG_CLIENT; // eslint-disable-line no-bitwise

const transitions = {
  [CLIENT_HELLO]: new Set([HELLO_VERIFY_REQUEST, SERVER_HELLO]), // default state
  [HELLO_VERIFY_REQUEST]: new Set([CLIENT_HELLO]),
  [SERVER_HELLO]: new Set([CERTIFICATE]), // We use key exchange methods with certificate.
  [CERTIFICATE]: new Set([SERVER_KEY_EXCHANGE, SERVER_HELLO_DONE]),
  [CLIENT_CERTIFICATE]: new Set([
    CLIENT_KEY_EXCHANGE,
    CLIENT_CHANGE_CIPHER_SPEC,
  ]),
  [SERVER_KEY_EXCHANGE]: new Set([CERTIFICATE_REQUEST, SERVER_HELLO_DONE]),
  [SERVER_HELLO_DONE]: new Set([CLIENT_KEY_EXCHANGE, CLIENT_CERTIFICATE]),
  [CLIENT_KEY_EXCHANGE]: new Set([
    CERTIFICATE_VERIFY,
    CLIENT_CHANGE_CIPHER_SPEC,
  ]),
  [CERTIFICATE_VERIFY]: new Set([CLIENT_CHANGE_CIPHER_SPEC]),
  [CHANGE_CIPHER_SPEC]: new Set([FINISHED]),
  [CLIENT_CHANGE_CIPHER_SPEC]: new Set([CLIENT_FINISHED]),
  [FINISHED]: null,
  [CLIENT_FINISHED]: new Set([CHANGE_CIPHER_SPEC]),
};

const _session = Symbol('_session');
const _message = Symbol('_message');

const _clientHello = Symbol('_client_hello');
const _helloVerifyRequest = Symbol('_hello_verify_request');
const _serverHello = Symbol('_server_hello');
const _serverCertificate = Symbol('_server_certificate');
const _serverHelloDone = Symbol('_server_hello_done');
const _clientKeyExchange = Symbol('_client_key_exchange');
const _clientFinished = Symbol('_client_finished');
const _clientChangeCipherSpec = Symbol('_client_change_cipher_spec');
const _serverFinished = Symbol('_server_finished');
const _serverChangeCipherSpec = Symbol('_server_change_cipher_spec');
const _alert = Symbol('_alert');
const _applicationData = Symbol('_application_data');

const handlers = {
  [CLIENT_HELLO]: _clientHello,
  [HELLO_VERIFY_REQUEST]: _helloVerifyRequest,
  [SERVER_HELLO]: _serverHello,
  [CERTIFICATE]: _serverCertificate,
  [SERVER_HELLO_DONE]: _serverHelloDone,
  [CLIENT_KEY_EXCHANGE]: _clientKeyExchange,
  [CLIENT_CHANGE_CIPHER_SPEC]: _clientChangeCipherSpec,
  [CLIENT_FINISHED]: _clientFinished,
  [CHANGE_CIPHER_SPEC]: _serverChangeCipherSpec,
  [FINISHED]: _serverFinished,
};

module.exports = class Protocol12ReaderClient extends Writable {
  /**
   * @constructor
   * @param {AbstractSession} session
   */
  constructor(session) {
    super({ objectMode: true, decodeStrings: false });
    this[_session] = session;
    this[_message] = null;
    session.handshakeProtocolReaderState = null;
  }

  /**
   * @returns {AbstractSession}
   */
  get session() {
    return this[_session];
  }

  /**
   * @returns {number|null}
   */
  get state() {
    return this.session.handshakeProtocolReaderState;
  }

  /**
   * Last received message.
   * @returns {object|null}
   */
  get message() {
    return this[_message];
  }

  /**
   * Starts a new client-side handshake flow.
   */
  start() {
    this.session.startHandshake(() => this.next(CLIENT_HELLO));
  }

  /**
   * Switch to the next state.
   * @param {number} state
   */
  next(state) {
    if (this.state !== null) {
      /** @type {Set<number>} */
      const allowedStates = transitions[this.state];

      assert(
        allowedStates.has(state),
        `Forbidden transition from ${this.state} to ${state}`
      );
    }

    this.session.handshakeProtocolReaderState = state;
    this[handlers[state]]();
  }

  /**
   * @private
   * @param {object} record
   * @param {string} encoding
   * @param {function} callback
   */
  _write(record, encoding, callback) {
    this[_message] = record;

    const protocol = record.type;

    const isAlert = protocol === contentType.ALERT;
    const isAppData = protocol === contentType.APPLICATION_DATA;
    const isHandshake = protocol === contentType.HANDSHAKE;

    if (isAlert) {
      this[_alert]();
    } else if (!this.session.isHandshakeInProcess && isAppData) {
      this[_applicationData]();
    } else {
      const type = isHandshake ? record.fragment.type : 0;
      const state = createState(protocol, type);

      this.next(state);

      if (isHandshake) {
        this.session.lastRvHandshake = record.fragment.sequence;
      }
    }

    this[_message] = null;
    callback();
  }

  /**
   * @private
   */
  _destroy() {
    this[_session] = null;
    this[_message] = null;
  }

  /**
   * Handles `client hello` out message
   * @private
   */
  [_clientHello]() {
    debug('prepare client hello');
    this.session.send(this.state);
    this.session.retransmitter.send();
  }

  /**
   * Handles `hello verify request` incoming message
   * @private
   */
  [_helloVerifyRequest]() {
    debug('got hello verify request');
    this.session.retransmitter.prepare();

    const handshake = this.message.fragment;

    // Initial `ClientHello` and `HelloVerifyRequest` must not
    // use for calculate finished checksum.
    this.session.resetHandshakeQueue();

    try {
      const packet = decode(handshake.body, HelloVerifyRequest);
      assert(decode.bytes === handshake.body.length);

      this.session.cookie = packet.cookie;
      debug('got cookie %h', packet.cookie);

      this.next(CLIENT_HELLO);
    } catch (err) {
      debug(err);
      this.session.error(alertDescription.DECODE_ERROR);
    }
  }

  /**
   * Handles `server hello` incoming message
   * @private
   */
  [_serverHello]() {
    debug('got server hello');
    const handshake = this.message.fragment;

    if (handshake.body.length < 38) {
      this.session.error(alertDescription.DECODE_ERROR);
      return;
    }

    try {
      const serverHello = decode(handshake.body, ServerHello);

      if (serverHello.serverVersion !== this.session.version) {
        debug('mismatch protocol version');
        this.session.error(alertDescription.PROTOCOL_VERSION);
        return;
      }

      if (serverHello.sessionId.length > maxSessionIdSize) {
        this.session.error(alertDescription.ILLEGAL_PARAMETER);
        return;
      }

      this.session.serverRandom = serverHello.random;
      this.session.id = serverHello.sessionId;

      const defaultCipherSuites = defaultCiphers();
      const cipher = defaultCipherSuites.find(
        cipherSuite => cipherSuite.id === serverHello.cipherSuite
      );

      if (!cipher) {
        debug('server selected unknown cipher %s', serverHello.cipherSuite);
        this.session.error(alertDescription.HANDSHAKE_FAILURE);
        return;
      }

      debug(`server selected ${cipher.name} cipher`);
      this.session.nextCipher = cipher;

      this.session.appendHandshake(handshake);
    } catch (err) {
      debug(err);
      this.session.error(alertDescription.DECODE_ERROR);
    }
  }

  /**
   * Handles `certificate` incoming message
   * @private
   */
  [_serverCertificate]() {
    debug('got server certificate');
    const handshake = this.message.fragment;

    try {
      const packet = decode(handshake.body, Certificate);

      if (packet.certificateList.length === 0) {
        this.session.error(alertDescription.CERTIFICATE_UNKNOWN);
        return;
      }

      const certificate = packet.certificateList[0];
      const x509Certificate = x509.parse(certificate);

      this.session.certificate(x509Certificate);

      this.session.serverPublicKey = x509.getPublicKeyPem(x509Certificate);

      this.session.appendHandshake(handshake);
    } catch (err) {
      debug(err);
      this.session.error(alertDescription.DECODE_ERROR);
    }
  }

  /**
   * Handles `server hello done` incoming message
   * @private
   */
  [_serverHelloDone]() {
    debug('got server hello done');
    const handshake = this.message.fragment;

    this.session.appendHandshake(handshake);
    this.session.createPreMasterSecret(() => this.next(CLIENT_KEY_EXCHANGE));
  }

  /**
   * @private
   */
  [_clientKeyExchange]() {
    debug('prepare client key exchange');
    this.session.retransmitter.prepare();
    this.session.send(this.state);
    this.next(CLIENT_CHANGE_CIPHER_SPEC);
  }

  /**
   * @private
   */
  [_clientChangeCipherSpec]() {
    debug('prepare change cipher spec');
    this.session.createMasterSecret();
    this.session.send(CHANGE_CIPHER_SPEC);
    this.session.nextEpochClient();
    this.next(CLIENT_FINISHED);
  }

  /**
   * @private
   */
  [_clientFinished]() {
    debug('prepare client finished');
    this.session.createFinished();
    debug('client finished %h', this.session.clientFinished);
    this.session.send(FINISHED);
    this.session.retransmitter.send();
  }

  /**
   * @private
   */
  [_serverChangeCipherSpec]() {
    debug('got change cipher spec');
    this.session.nextEpochServer();
  }

  /**
   * @private
   */
  [_serverFinished]() {
    debug('got finished');
    const handshake = this.message.fragment;

    debug('server finished %h', handshake.body);

    // TODO: explicitly check finished checksum

    this.session.retransmitter.finish();
    this.session.finishHandshake();
  }

  /**
   * Handle incoming `alert` messages
   * @private
   */
  [_alert]() {
    debug('got alert');
    const packet = this.message.fragment;
    const alert = decode(packet, Alert);
    debug('level %s, description %s', alert.level, alert.description);

    this.session.error(alert.description);
  }

  /**
   * Handle incoming `application data` message
   * @private
   */
  [_applicationData]() {
    debug('got application data');

    const appdata = this.message.fragment;
    debug('packet: %h', appdata);

    this.session.packet(appdata);
  }
};
