'use strict';

const assert = require('assert');
const { Readable } = require('stream');

const PREPARING = 'preparing';
const SENDING = 'sending';
const WAITING = 'waiting';
const FINISHED = 'finished';

const _timer = Symbol('_timer');
const _state = Symbol('_state');
const _timeout = Symbol('_timeout');
const _next = Symbol('_next_state');
const _queue = Symbol('_queue');
const _onTimeout = Symbol('_on_timeout');
const _stopTimer = Symbol('_stop_timer');
const _resetTimer = Symbol('_reset_timer');

/**
 * Allowed state transitions.
 * @see https://tools.ietf.org/html/rfc6347#section-4.2.4
 */
const transitions = {
  [PREPARING]: new Set([SENDING]),
  [SENDING]: new Set([WAITING, FINISHED]),
  [WAITING]: new Set([PREPARING, FINISHED]),
  [FINISHED]: new Set([PREPARING]),
};

/**
 * Timeout and Retransmission State Machine.
 */
class RetransmitMachine extends Readable {
  /**
   * @constructor
   * @param {string} initialState
   */
  constructor(initialState) {
    super();

    this[_timer] = null;
    this[_timeout] = 1e3; // Initial timer is 1s
    this[_state] = initialState;

    const queue = [];
    this[_queue] = queue;

    this.on('timeout', () => {
      if (queue.length === 0) {
        return;
      }

      this.send();
      queue.forEach(chunk => this.push(chunk));
      this.wait();
    });
  }

  /**
   * Get the current state of the State Machine.
   */
  get state() {
    return this[_state];
  }

  /**
   * Change state to `FINISHED`
   */
  finish() {
    this[_stopTimer]();
    this[_queue].length = 0;

    this[_next](FINISHED);
  }

  /**
   * Change state to `WAITING`
   */
  wait() {
    this[_resetTimer]();
    this[_next](WAITING);
  }

  /**
   * Change state to `SENDING`
   */
  send() {
    this[_next](SENDING);
  }

  /**
   * Change state to `PREPARING`
   */
  prepare() {
    this[_stopTimer]();
    this[_queue].length = 0;

    this[_next](PREPARING);
  }

  /**
   * Create a new flight and buffer it
   * @param {Buffer} packet handshake messages
   */
  appendHandshake(packet) {
    assert(this.state === PREPARING);

    this[_queue].push(packet);
  }

  /**
   * @private
   */
  _read() {} // eslint-disable-line class-methods-use-this

  /**
   * @private
   */
  _destroy() {
    this[_queue].length = 0;
    this[_stopTimer]();
  }

  /**
   * @private
   * @param {RetransmitMachine} that
   */
  [_onTimeout](that) {
    const instance = that || this;

    /**
     * Double the value at each retransmission
     * @see https://tools.ietf.org/html/rfc6347#section-4.2.4.1
     */
    const time = this[_timeout] * 2;
    this[_timeout] = time > 60e3 ? 60e3 : time;

    instance.emit('timeout');
  }

  /**
   * @private
   * @param {string} state new state
   */
  [_next](state) {
    /** @type {Set} */
    const allowedStates = transitions[this.state];

    assert(
      allowedStates.has(state),
      `Forbidden transition from ${this.state} to ${state}`
    );

    this[_state] = state;
    this.emit(state);
  }

  /**
   * Stops the retransmission timer.
   * @private
   */
  [_stopTimer]() {
    if (this[_timer] !== null) {
      clearTimeout(this[_timer]);
    }

    this[_timer] = null;
  }

  /**
   * Restarts the retransmission timer.
   * @private
   */
  [_resetTimer]() {
    this[_stopTimer]();

    this[_timer] = setTimeout(this[_onTimeout], this[_timeout], this);
    this[_timer].unref();
  }
}

/**
 * Create Timeout and Retransmission State Machine
 * for the clients.
 * @returns {RetransmitMachine}
 */
function createRetransmitClient() {
  return new RetransmitMachine(PREPARING);
}

/**
 * Create Timeout and Retransmission State Machine
 * for the servers.
 * @returns {RetransmitMachine}
 */
function createRetransmitServer() {
  return new RetransmitMachine(WAITING);
}

module.exports = {
  createRetransmitClient,
  createRetransmitServer,
  RetransmitMachine,
  states: {
    PREPARING,
    SENDING,
    WAITING,
    FINISHED,
  },
};
