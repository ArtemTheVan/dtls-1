'use strict';

const { Transform } = require('stream');
const { contentType } = require('lib/constants');
const debug = require('utils/debug')('dtls:reorder');

const _session = Symbol('_session');
const _queue = Symbol('_queue');

/**
 * Handles reordering of handshake message.
 */
module.exports = class Reordering extends Transform {
  /**
   * @constructor
   * @param {AbstractSession} session
   */
  constructor(session) {
    super({ objectMode: true });

    this[_session] = session;
    this[_queue] = [];
  }

  /**
   * @return {AbstractSession}
   */
  get session() {
    return this[_session];
  }

  /**
   * @private
   * @param {object} record record / handshake message
   * @param {string} enc
   * @param {function} callback
   */
  _transform(record, enc, callback) {
    // сохранять порядок в текущей эпохе
    // только при handshake
    // finished должен быть после change_cipher_spec
    // сбрасывать очередь при таймауте

    const isEpochEquals = record.epoch === this.session.serverEpoch;
    const isHandshake = record.type === contentType.HANDSHAKE;
    const isReplay =
      isHandshake && record.fragment.sequence <= this.session.lastRvHandshake;

    if (this.session.isHandshakeInProcess) {
      // Drop replays.
      if (isHandshake && isReplay) {
        debug('replay detected, drop');
        callback();
        return;
      }
    } else if (!isEpochEquals) {
      // Drop messages from an unknown epoch
      // if not in handshake state.
      debug('drop message from an unknown epoch');
      callback();
      return;
    }

    // TODO: sort arrived packets using seq number
    // this[_queue].push(record);
    debug('success');
    callback(null, record);
  }
};
