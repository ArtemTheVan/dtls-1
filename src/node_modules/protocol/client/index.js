'use strict';

const { Writable } = require('readable-stream');
const StateMachine = require('lib/state-machine');
const { constants: states, createState } = require('protocol/states');
const ClientSession = require('session/client'); // eslint-disable-line no-unused-vars
const { contentType } = require('lib/constants');
const handlers = require('protocol/client/handlers');

const _session = Symbol('session');
const _message = Symbol('message');
const _state = Symbol('state');

const {
  CLIENT_HELLO,
  SERVER_HELLO,
  HELLO_VERIFY_REQUEST,
  CERTIFICATE,
  SERVER_KEY_EXCHANGE,
  CERTIFICATE_REQUEST,
  SERVER_HELLO_DONE,
  CERTIFICATE_VERIFY,
  CLIENT_KEY_EXCHANGE,
  FINISHED,
  CHANGE_CIPHER_SPEC,
} = states;

const FLAG_CLIENT = 2 ** 16 + 1;

const CLIENT_CERTIFICATE = CERTIFICATE | FLAG_CLIENT; // eslint-disable-line no-bitwise
const CLIENT_FINISHED = FINISHED | FLAG_CLIENT; // eslint-disable-line no-bitwise
const CLIENT_CHANGE_CIPHER_SPEC = CHANGE_CIPHER_SPEC | FLAG_CLIENT; // eslint-disable-line no-bitwise

// Transitions of state machine.
const transitions = {
  [CLIENT_HELLO]: new Set([HELLO_VERIFY_REQUEST, SERVER_HELLO]), // default state
  [HELLO_VERIFY_REQUEST]: new Set([CLIENT_HELLO]),
  [SERVER_HELLO]: new Set([
    CERTIFICATE,
    SERVER_KEY_EXCHANGE,
    SERVER_HELLO_DONE,
  ]),
  [CERTIFICATE]: new Set([
    SERVER_KEY_EXCHANGE,
    CERTIFICATE_REQUEST,
    SERVER_HELLO_DONE,
  ]),
  [CLIENT_CERTIFICATE]: new Set([
    CLIENT_KEY_EXCHANGE,
    CLIENT_CHANGE_CIPHER_SPEC,
  ]),
  [SERVER_KEY_EXCHANGE]: new Set([CERTIFICATE_REQUEST, SERVER_HELLO_DONE]),
  [CERTIFICATE_REQUEST]: new Set([SERVER_HELLO_DONE]),
  [SERVER_HELLO_DONE]: new Set([CLIENT_KEY_EXCHANGE, CLIENT_CERTIFICATE]),
  [CLIENT_KEY_EXCHANGE]: new Set([
    CERTIFICATE_VERIFY,
    CLIENT_CHANGE_CIPHER_SPEC,
  ]),
  [CERTIFICATE_VERIFY]: new Set([CLIENT_CHANGE_CIPHER_SPEC]),
  [CHANGE_CIPHER_SPEC]: new Set([FINISHED]),
  [CLIENT_CHANGE_CIPHER_SPEC]: new Set([CLIENT_FINISHED]),
  [FINISHED]: null,
  [CLIENT_FINISHED]: new Set([CHANGE_CIPHER_SPEC]),
};

const {
  clientHello,
  helloVerifyRequest,
  serverHello,
  serverCertificate,
  serverKeyExchange,
  certificateRequest,
  serverHelloDone,
  clientCertificate,
  clientKeyExchange,
  certificateVerify,
  clientChangeCipherSpec,
  clientFinished,
  serverChangeCipherSpec,
  serverFinished,
  alert,
  applicationData,
} = handlers;

/**
 * This class implements DTLS v1.2 using finite state machine.
 */
class ClientProtocol extends Writable {
  /**
   * @class ClientProtocol
   * @param {ClientSession} session
   */
  constructor(session) {
    super({ objectMode: true, decodeStrings: false });
    this[_message] = null;
    this[_session] = session;

    const state = new StateMachine(transitions);
    this[_state] = state;

    setup(state, this);
  }

  /**
   * @returns {ClientSession}
   */
  get session() {
    return this[_session];
  }

  /**
   * Last received message.
   * @returns {Object|null}
   */
  get message() {
    return this[_message];
  }

  /**
   * Get internal state machine.
   * @returns {StateMachine}
   */
  get state() {
    return this[_state];
  }

  /**
   * Starts a new client-side handshake flow.
   */
  start() {
    this.session.startHandshake(() => this.state.next(CLIENT_HELLO));
  }

  /**
   * @private
   * @param {Object} record
   * @param {string} encoding
   * @param {Function} callback
   */
  _write(record, encoding, callback) {
    this[_message] = record;

    const protocol = record.type;

    const isAlert = protocol === contentType.ALERT;
    const isApplicationData = protocol === contentType.APPLICATION_DATA;
    const isHandshake = protocol === contentType.HANDSHAKE;

    if (isAlert) {
      alert(this.session, record);
    } else if (!this.session.isHandshakeInProcess && isApplicationData) {
      applicationData(this.session, record);
    } else {
      const type = isHandshake ? record.fragment.type : 0;
      const state = createState(protocol, type);

      // Process current message.
      this.state.next(state);

      if (isHandshake) {
        this.session.lastRvHandshake = record.fragment.sequence;
      }
    }

    if (protocol !== contentType.CHANGE_CIPHER_SPEC) {
      this.session.window.accept(record.sequenceNumber);
    }

    this[_message] = null;
    callback();
  }

  /**
   * @private
   */
  _destroy() {
    this[_session] = null;
    this[_message] = null;
    this[_state] = null;
  }
}

/**
 * Set up session handlers.
 * @param {StateMachine} state
 * @param {ClientProtocol} protocol
 */
function setup(state, protocol) {
  state.on(CLIENT_HELLO, () => clientHello(protocol.session, protocol.message));
  state.on(HELLO_VERIFY_REQUEST, () => {
    helloVerifyRequest(protocol.session, protocol.message);
    protocol.state.next(CLIENT_HELLO);
  });
  state.on(SERVER_HELLO, () => serverHello(protocol.session, protocol.message));
  state.on(CERTIFICATE, () =>
    serverCertificate(protocol.session, protocol.message)
  );
  state.on(SERVER_KEY_EXCHANGE, () =>
    serverKeyExchange(protocol.session, protocol.message)
  );
  state.on(CERTIFICATE_REQUEST, () =>
    certificateRequest(protocol.session, protocol.message)
  );
  state.on(SERVER_HELLO_DONE, () =>
    serverHelloDone(protocol.session, protocol.message, () => {
      const nextState = protocol.session.isCertificateRequested
        ? CLIENT_CERTIFICATE
        : CLIENT_KEY_EXCHANGE;
      protocol.state.next(nextState);
    })
  );
  state.on(CLIENT_CERTIFICATE, () => {
    clientCertificate(protocol.session);
    protocol.state.next(CLIENT_KEY_EXCHANGE);
  });
  state.on(CLIENT_KEY_EXCHANGE, () => {
    clientKeyExchange(protocol.session);

    const nextState = protocol.session.needCertificateVerify
      ? CERTIFICATE_VERIFY
      : CLIENT_CHANGE_CIPHER_SPEC;
    protocol.state.next(nextState);
  });
  state.on(CERTIFICATE_VERIFY, () => {
    certificateVerify(protocol.session);
    protocol.state.next(CLIENT_CHANGE_CIPHER_SPEC);
  });
  state.on(CLIENT_CHANGE_CIPHER_SPEC, () => {
    clientChangeCipherSpec(protocol.session);
    protocol.state.next(CLIENT_FINISHED);
  });
  state.on(CLIENT_FINISHED, () => clientFinished(protocol.session));
  state.on(CHANGE_CIPHER_SPEC, () => serverChangeCipherSpec(protocol.session));
  state.on(FINISHED, () => serverFinished(protocol.session, protocol.message));
}

module.exports = ClientProtocol;
